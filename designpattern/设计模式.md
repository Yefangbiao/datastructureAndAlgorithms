## 设计模式



思维比具体模式更重要。

要注重原则，把模式看作示例。而不是注重示例，忽略思维。



了解设计模式，首要必须了解的就是**面向对象**

你需要了解：

+ 抽象
+ 封装
+ 继承
+ 多态



**优秀设计模式的特征**

+ 代码复用
+ 扩展性



### 设计原则



#### 1.依赖倒置原则（DIP）

高层模块（稳定）不应该依赖于低层模块（变化），二者应该都依赖于抽象（稳定）

抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）

#### 2.开闭原则（OCP）

+ 对扩展开放
+ 对更改封闭

#### 3.单一职责原则（SRP）

+ 一个类仅有一个引起它变化的原因

#### 4.Liskov替换原则（LSP）

+ 子类必须能够替换它们的基类（IS-A）

#### 5.接口隔离原则（ISP）

+ 客户端不应当依赖于其不使用的方法

+ 缩小接口

#### 6.优先使用对象组合，而不是类继承

#### 7.面向接口编程，而不是实现编程

#### 8.封装变化的内容



• 创建型模式提供创建对象的机制， 增加已有代码的灵活性和 可复用性。

• 结构型模式介绍如何将对象和类组装成较大的结构， 并同时 保持结构的灵活和高效。

• 行为模式负责对象间的高效沟通和职责委派。



## 创建型模式

### 工厂方法

工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许**子类决定实例化对象的类型**。

工厂方法模式建议使用特殊的工厂方法代替对于对象构造函 数的直接调用（即使用 new 运算符）。 不用担心， 对象仍将 通过 new 运算符创建， 只是该运算符改在工厂方法中调用 罢了。 工厂方法返回的对象通常被称作“产品”。



### 抽象工厂

**抽象工厂**是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类



### 生成器模式（建造者模式）

**生成器模式**是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。



### 原型

**原型**是一种创建型设计模式，使 你能够复制已有对象，而又无需 使代码依赖它们所属的类。



### 单例

**单例是**一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。



## 结构型模式

### 适配器

**适配器**是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。



### 桥接

**桥接**是一种结构型设计模式，可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。



### 组合

**组合**是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。



### 装饰模式

**装饰**是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。



### 外观模式

**外观**是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。



### 享元模式

**享元**是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。



### 代理

**代理**是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。



## 行为模式

### 责任链模式

**责任链**是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。

